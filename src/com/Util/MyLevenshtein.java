package com.Util;

/** 
 * @className:MyLevenshtein.java 
 * @classDescription:Levenshtein Distance �㷨ʵ�� 
 * ����ʹ�õĵط���DNA���� ����ƴ�ּ�� ����������ʶ ������Ϯ��� 
 */  
public class MyLevenshtein {  
  
    public static void main(String[] args) {  
    	String str1 ="提高软件质量属性可修改性的方法\r\n" + 
    			"刘宏琦\r\n" + 
    			"(石家庄铁道大学)\r\n" + 
    			"[摘要]:通过对软件体系架构的质量属性学习，对软件体系架构的质量属性的可修改性进行分析。软件体系架构质量属性包括六方面：可用性、可修改性、性能、安全性、可测试性以及易用性。通过对质量属性的改进，以提高系统的质量、改善系统安全等问题，质量属性是软件体系架构的一项重要内容，可修改性是软件体系架构质量属性的一个重要内容，它是有关变更成本的问题，即一个软件的成本与可修改性有关。本文将从可修改性的概念、场景等方面分析，进而提出一些提高可修改性的方法。\r\n" + 
    			"[关键词]：软件体系架构；质量属性；可修改性\r\n" + 
    			"\r\n" + 
    			"A Method to Improve the Modibility of Software Quality Attributes\r\n" + 
    			"Liu Hong Qi\r\n" + 
    			"Shijiazhuang Tiedao University\r\n" + 
    			"[Abstract]: By learning the quality attributes of software architecture, the modifiability of the quality attributes of software architecture is analyzed. The quality attributes of software architecture include six aspects: availability, modifiability, performance, security, testability and ease of use. Through the improvement of quality attributes in order to improve the quality and security of the system, quality attributes are an important part of the software architecture, and modifiability is an important part of the quality attributes of the software architecture. It is related to the cost of change, that is, the cost of a software is related to modifiability. This paper will analyze the concept and scenario of modifiability, and then put forward some methods to improve modifiability. \r\n" + 
    			"[Key words]: Software architecture; quality attributes; modifiability\r\n" + 
    			"\r\n" + 
    			"0 引言\r\n" + 
    			"	软件体系架构的质量属性有六个方面：可用性、可修改性、性能、安全性、可测试性以及易用性。系统架构可以从这六个方面分析一个系统的健全程度，通过完善质量属性的完美度以达到系统的需求，满足用户以及系统的需要。系统的需求一般分为两个获取途径：用户直接提出，包括功能性需求以及领域知识；另一种是架构时设计的需求，通过与用户的对话和沟通，得到更明确的需求。软件架构师通过软件系统的质量属性的六个方面提出问题，进而逐渐引导出用户的实际需要，以满足用户对系统的满意度，对系统的设计和实现提供了巨大帮助。软件架构的质量属性一般需要场景来统一规范表达需求。表达质量属性的手段有六部分：刺激源、刺激、环境、制品、响应以及响应度量。通过对这六部分的具体描述，表达出质量属性的具体需求，使人们更加快速、容易理解系统的某个需求，以达到系统架构设计的目的，满足系统的需要。\r\n" + 
    			"	可修改性是便于软件系统的修改、维护和升级等。 软件的可修改性是非常重要的，软件修改、维护和升级都与可修改性有关。软件系统需要被修改或者重写，重写的成本是非常巨大的，所以软件的可修改是一个关于软件系统成本的至关重要的内容。\r\n" + 
    			"1 可修改性的定义及分析\r\n" + 
    			"1.1	定义\r\n" + 
    			"可修改性是有关变更成本的问题。在这个基础上有两个方面的问题来制约着可修改性，即可修改什么和何时进行以及由谁变更。\r\n" + 
    			"	在可修改什么方面，最简单的就是修改软件系统的功能、运行环境、运行平台以及系统的质量属性（性能、可用性及可修改性）等。在另一方面，最简单的就是修改源代码（开发人员修改源代码）、上架货物（商家在后台修改上架货物）等。\r\n" + 
    			"1.2	分析\r\n" + 
    			"从六部分来分析可用性的一般场景：\r\n" + 
    			"场景	值\r\n" + 
    			"刺激源	用户、开发人员、管理员等\r\n" + 
    			"刺激	增加、修改、删除功能、质量属性、容量等\r\n" + 
    			"环境	在软件系统运行、编译、设计时\r\n" + 
    			"制品	系统的界面、运行平台、运行环境及交互\r\n" + 
    			"\r\n" + 
    			"响应	找到要修改的位置，在修改时不会对整个系统或者其他功能产生影响，对修改的位置进行测试、发布\r\n" + 
    			"\r\n" + 
    			"响应度量	根据修改的难易程度度量成本；度量修改对其他功能或者是质量属性产生的影响程度\r\n" + 
    			"\r\n" + 
    			"2	提高可修改性的方法\r\n" + 
    			"2.1	使各个模块独立\r\n" + 
    			"提高模块的独立性，使各个模块独立而不相互制约，进行修改时只需要修改独立的模块而不是整个系统，可以防止连锁反应的发生，进而能够提高软件系统的可修改性。开发具有独立功能的模块减少与其他模块的相互作用，减少模块之间的依赖，从而做到模块的独立。\r\n" + 
    			"模块的独立有两个度量标准：耦合和内聚（模块间的联系和模块内的联系）。耦合是衡量不同模块之间依赖的紧密程度，模块之间的联系依赖越小，模块的耦合程度越低，独立程度越高。在模块设计时，使用调用语句实现模块之间的调用，减少数据的直接传输，从而能够保证系统模块的清晰，减少耦合程度，提高模块的独立性。内聚是模块内部的各个元素的紧密程度。提高模块内部元素的紧密程度，进而可以提高模块的内聚程度。采用“高内聚，低耦合”的设计方式，可以提高模块的独立性。\r\n" + 
    			"2.2	实现接口编程\r\n" + 
    			"在模块设计时，一个模块如果不得不依赖于其他模块，可以采用接口依赖的方式。在修改一个单独模块的时候，需要保持接口不变，进而保证其他的模块不需要被修改，提高了系统的可修改性。在设计模式中，模块变化但是接口保持不变的有几个相关模式，比如：适配器模式、装饰器模式、代理模式等。\r\n" + 
    			"2.3	面向对象的技术\r\n" + 
    			"采用面向对象的技术。对象的一个特点是封闭性（封装性），是将过程和数据整个包围起来，对数据的访问只能通过已经定义的界面，具有很强的独立性。它是实现模块独立的理想方法。对象通过一个受保护的接口访问其他对象，从外部只能看到对象的外部特征，而对象的内部特征，私有数据等是外部不能看见、修改和访问的。对象的这种性质成为信息隐藏，开发人员只需要知道类的外部说明就能使用它们，不需要知道私有数据的说明和封装内部函数的实现。\r\n" + 
    			"封装保证了模块具有较好的独立性，使系统维护、修改较为容易，对修改只限于封装类的内部，可以将修改的影响减少到最低程度。例如：面向对象程序设计的继承性，在修改或者添加程序代码时，不必修改源程序，只需添加新的代码或者类，从而减少了工作量，提高了可修改性。\r\n" + 
    			"代码重用，我们通常称为代码复用，把一个功能写成一个模块，以便当再次需要相同功能的时候，可以直接使用，而不用重新开发。代码复用就是采用面向对象的封装和继承特点，从而使系统修改更加容易。\r\n" + 
    			"2.4	降低修改的影响\r\n" + 
    			"如果修改时无法避免接口以及模块的修改，所以在模块或者类设计或者时按照职责分配，提高内聚性；利用中介将外部的几个模块都依赖修改的转化成依赖中介，让中介类依赖一个修改，为软件的修改和维护留下修改的余地。这需要积累大量经验，是架构师必备的能力。例如：一个购物网站需要预留增加商品类别的模块而不是固定几类，方便之后添加新类别的商品。\r\n" + 
    			"3	总结\r\n" + 
    			"程序的可修改性非常重要，在时代变化下，软件系统在新的条件下可能不能满足用户的需要，或者是在软件开发初期就没有弄懂需求在后期时明白后需要修改之前的代码。可修改性是有关开发成本的问题，所以提高软件系统的可修改性是节约软件项目成本的一项基本属性。一个系统的可修改性太差会影响后期的修改及维护，需要大量的成本去完善。所以提高软件的可修改性大大减少了后期的困难程度。提高软件系统的可修改性的方法还有很多，比如采用结构化程序设计方法、模块的作用域是控制域的子集，等等。\r\n" + 
    			"";
   			String str2 ="提高软件可修改性的若干方法\r\n" + 
   					"林 志 斌 ( 交 通部广州信 .么技术研 究所)\r\n" + 
   					"摘要 本文结 合 笔者开发 M I S 软件的 经脸 、 体会 , 提 出 了提 高软件 可修改 性 的 若干方 法 : 使 用数据库、 修改精入城 、 信 .息屏蔽 、 提 高模块独立性 、 面 向对象程 序设计 、 为修改留下余 地 。 关键词 软件 可修改性 数据库 厂 信息屏蔽 独立性 面向对象\r\n" + 
   					"一 、 前 言\r\n" + 
   					"软件的可靠性 、 可维护性 、 性能构成了衡量软件质量的几个主要尺度 , 也是用户十分关心 的 几个方面 。 统计表明 , 维护期花费 占整个生命期的6 7 % , 这是一个相当可观的数字 。 软件的维 护分为正确性维护 , 适应性维护 , 完善性维护 , 预防性维护 。 无论那一种维护都要修改软件 。 软 件的可维护性包括可理解性 , 可测试性 , 可修改性 . 提高软件的可修改性可提高软件的可维护\r\n" + 
   					"性\r\n" + 
   					"。\r\n" + 
   					"卞面具体谈谈提高软件可修改性的几种方法 .\r\n" + 
   					"二 、 使用数据库\r\n" + 
   					"尽管应用软件可执行数据完整性检查 , 但若让数据库来处理这个问题会更简单 , 出错的可 能性也较小 。 例如 , 若特定课程具有先修课 , 并限制人数或其它别的限制条件 , 那么如果应用软 件负责检查这些限制 , 则安排学生修课的每个应用 程序都必须包含这些条件检查的代码 , 并且 每次条件 变化时 ; 则所有的应用 程序都必须修改 。 , 相反 , 数据库则不同 , 它把条件放在数据库中 , 因而可以容易地更改数据库以反映限制条 件的改变也就是说 , 把数据修改的任务留给了数据库本身 。 现在流行的通用 下拉式菜单技术就是把菜单存放在数据库中 。 首先定 义一个数据库 , 存放可变的菜单信息 , 它的字段结构描述如下 :\r\n" + 
   					"字段名 类型 宽度 用 途\r\n" + 
   					"B H 字符型 5\r\n" + 
   					"X X 字符型 2 0\r\n" + 
   					"存放菜单项 目编号 , 第一位表示第一层菜单的项 目编号 . 第二位表示第二层菜单的项 目编号 ·\r\n" + 
   					"一\r\n" + 
   					"第五位表示第五层菜单的项 目编号 .\r\n" + 
   					"存放菜单项 目信息\r\n" + 
   					"软 件 1 9 9 5 年 第 10 一 1 1 期\r\n" + 
   					"M K 字符型 1 1\r\n" + 
   					"存放该项 目执 行的模块名 , 如果 为空 , 则继续 调用 下级菜单 , R E T u R N 返 回 上级菜单\r\n" + 
   					"数据库的内容可根据不同的应用 自行设置 . 例如\r\n" + 
   					"B H X X M K 1 发票处理 2 提油单处理 3 验收单处理 4 退出 Q U I T\r\n" + 
   					"1 1 发票录人 F P L R 1 2 发票修改 F P x G 13 发票查询 r P e X 1 4 返回 R E T U R N\r\n" + 
   					"通用菜单管理程序读数据库 , 取菜单项 目编号 、 菜单项 目信息 、 要执行模块名称 。 由于菜单信息包含在数据库中 , 所以修改起来很方便 。\r\n" + 
   					"三 、 修改输入域\r\n" + 
   					"软件修改 时往 往要带 来这样 那样 的 错 误 或 者副作 用 , 即通 常所 说的 波 及影 响 ( r i p p l e\r\n" + 
   					"e 什七 c t ) , 所 以应尽t 避免修改软件本身 。 而输 入域的 修改是容易的 , 也是确实 的 . 假设程序中用 到变t o r w , 并要多次对其赋 初值 5。 实现方法有三种 :\r\n" + 
   					"1\r\n" + 
   					". 用斌值语句 o r w 二 5 重新置初值时再 用该语句斌道 。 如果 R o w 的初值要改变 , 如果改为 6 , 则程序中所有的 o r w ~ 5语句都要改成 o r w ~ 6\r\n" + 
   					"。\r\n" + 
   					"这样很繁 , 而且容易出错 。\r\n" + 
   					"2\r\n" + 
   					".\r\n" + 
   					"把初值先斌给一个变最 , 然后再把 该变量赋给 : 。 w 。 例 : o r 屯i n ~ 5\r\n" + 
   					"r o w ~ o r 地i n 重新置初值时用 o r w 一 o r i s i n 语句赋 值 。\r\n" + 
   					"o r w 的初值要改变时 , 例如 要改为 6 , 仅将 o r i s i n 一 5改为 o r i g in 一 6就可以 了。 可修改性 大大提高 .\r\n" + 
   					"3\r\n" + 
   					".\r\n" + 
   					"o r w 的初值作为命令行参数 , 传递给变量 o r & i i n , 用 : 。 w 一 o r i i g n 语 句给 : 。 w 置初值 。 设文件名为 p巨 y , 以 F o x B A s E 语 言为例 , 执 行时 用 。。 p la y w r r H S即 可 。 初值被读人该软件 , 而不是嵌人程序 。 这样一来 , 不用改程序本身 , 只要改命令行参 数则可 , 方便 , 灵 活 。 上述三种方法中 , 可修改性从低到高 . 第 ,一种 方法不足取 , 第三种方法可 修改性最优 。 第二 种方法在实践 中也广 泛采用 , 仍不失为一 种好方法 . 例如 : 假 设程序中要多次用 s e t 。o l o o t 语句设置颜色 , 开 始选用红 色 ; e d , 所以 用 、 e t 。 o f o o t : 语\r\n" + 
   					"19 9 5 年 第 IU一 1 1期 软 件\r\n" + 
   					"句 , 后 觉得红 色太 * l J 眼 , 想改 为蓝色 b l u 。 于是 程序中所有 s e t c o f o o t r 语句都要 改成 s c t c o l o o t b , 很不 文 便。 如采用 如下方法 , 则修改起东很方便 : 一 , c ~ ” b即 , s e t e o l o t o 从 . 即先将颜色斌 给变量 C , 然后 用宏替换 阮 代表颜色 。 要改变颜色时只要把新 的颜色斌给 变量 。 即 可 。 例如 , 改蓝色后觉蓝色不是 合适的前 . 竞色 , 想改为绿色 s r 二n , 于是改 c = ` b , 为 c 一 ` 留 。 使用安 替换能大 大提高可修改性 。 当然 , 如果将颜色作为命令 行参数 , 贝 !J修改时会更 方便 `\r\n" + 
   					"四 、 信 `色屏蔽\r\n" + 
   					"大 型软 件系统一般是多个版本 的 , 在整个生命期 巾 往往要经 受多 次修改 , 所以在分解模块 时就应采 取措施使将来修改造成的影 响尽 可能局限在一个或少数几个模块的 内部 , 为了 达到 这个 目的 . P a r n a s 提 出了信息屏蔽 ( b 、r o r m a r so n H id ,n s ) 的原则 . 根据信息屏蔽原 则 , 概要设计可以这样进 行 :\r\n" + 
   					"1\r\n" + 
   					". 列 出可能发生 变化的因 素 , 把它们放在一起 .\r\n" + 
   					"2\r\n" + 
   					".\r\n" + 
   					"划分模块时将一些可 能发生 变化的 因素隐 含在某个模块内部 , 使其它模块与此因素无\r\n" + 
   					"关 。\r\n" + 
   					"对于这样构造的 软件系统 , 将来这些因素发生变化需作修改维 护时 , 只要改一个模块就够\r\n" + 
   					"了\r\n" + 
   					"。\r\n" + 
   					"其它模块可不受 影响 。 也 就是 说 , 信自 、 屏 蔽技术将某个因素隔离 在一个模块 内部 , 这 个因素 的 变化不致于传播到所在模块的 边界 之处 。 由千 修改极易引起错误 , 修改 的影 响范围越小则修 改 引起错误的可能性越小 。 例 如可以把依 赖于 具体运 行环境 和功能 要求 的部 分集 中在 少数几 个 模块 内 , 一 旦环瑰和 功能需 求发生变 化 , 就可 以 用 其它权 块 代替 , 通过 一些 局部 性的修改 , 在仍然保护整体稳定性 的 前提 下 , 适 恒新的环境和需 求 。\r\n" + 
   					"五\r\n" + 
   					"、\r\n" + 
   					"提 高模 块 独 立性\r\n" + 
   					"模块 化能够提高软 件的 可 修改性 。 开发 具有 独立功能而且和其 它模块间 没有过 多的相 互作 用的模块 。 就可以做到模块独立 。 独立 的模块容易维护 , 修改程序需要的工作量较小 , 错 误传播 范围小 。 模块 的独立程序可由两个定 性标准 变量 : 偶 合和聚 台 , 即块 间联 系和块 内联系 。 藕合衡量 不同模块 彼此间 互 相 农赖的 紧密程度 。 块间联系越刁 、 , 模块的独立性 越高 。 在设计 模块结构图时 , 应 尽量通过过程调用语句实现 块调 用。 模块调用时应传送 数据型参数 , 传送 的数据 应尽 可能 少 , 同时应 尽量 保持模块界面的 消晰性 , 以 减少模块 间 的块间联 系 , 提高模块 的独立性 。 聚合衡量一个模块 内部 各个元素彼此 结合的 紧密程度 。 块 内联 系按 从强到弱可分成 , ; 种不 同 类型 : 功能性 , 顺序性 , 通信性 , 瞬时性 , 逻辑性 , 偶然 性 。 功能性 , 顺 字性 , 通信性三 种块 内联 系是 由于模块 中的 成分共 用数据而 引起的 , 因而联 系比\r\n" + 
   					"软 件 ] 9 9 5 年 第 1 0一 1 1 期\r\n" + 
   					"较强 。 而瞬时性 , 逻辑性 , 偶然性三种块 内联系不是 由成分间共同信 息引起的 , 因而联系比较\r\n" + 
   					"弱\r\n" + 
   					"。\r\n" + 
   					"改进软件结构可提高块独立性 。 设计出软件的初步结构以后应该审查分析这个结构 , 通过 模块分解或合并 , 力求降低藕合 , 提高聚合。 例如 , 多个模块公有的一个子功能可以独立成一个 模块 , 由这些模块调用 , 有时可以通过分解或合并模块以减少控制信息的传递及对全局数据的 引用 , 并且降低接口 的复杂程度 。\r\n" + 
   					"六 、 面 向对象技 术\r\n" + 
   					"九十年代面向对象模型的实现使程序员和最终用户都受益匪浅 。 对象的一个重要特点是封闭性 , 它是数据和过程结合在一起的整个 , 具有很强的独立性 , 是实现模块的理想机制。 从外面只能看到对象的外部特性 , 即能够接受哪些信息 , 具有哪些处 理能力 , 而对象的内部特性 , 即实现处理能力的算法和保存 内部状态的私有数据对外是不可见 的 。 对私有数据不能执行该对象成员函数之外任何其它操作 , 对象的这种性质称为信息屏蔽 。 程序员只需知道类的外部说明就能使用它们 , 完全不必知道私有数据的说明 , 也不必知道函数 的实现算法 , 修改内部数据结构和函数的算法完全不影响其它程序成分的实现 。 信息屏蔽大大 提高了程序的可修改性。 面向对象程序设计语言的继承性 , 使得用户在修改和扩充程序时不必修改原有的程序代 码 , 只需增加新的代码 , 因而不必知道原有程序是怎样实现的 , 极大地减少了维护工作攀。\r\n" + 
   					"七 、 为修改 留下 余地\r\n" + 
   					"软件在设计、 编程和侧试时应注意到将来不可避免的修改 , 必 须时时处 处 为软件维 护着 想 , 为修改留下余地 。 例如 , 程序在编制时 , 应尽量注意可用资源 (主存 、 磁盘等 )的节约使用 , 以便为修改留下余 地。 又如 , 在一个文件里 , 页码 、 图号和表格号都按对应的章节编制 , 即1 一 1 , 1 一 2 , …… , 2一 1 , 2一 2 , …… 等等 , 以便插人或删除 , 而不会引起全面的不必要的重新编制文件号码 。 又如一个程序不要写成一大整块 , 否则不适于分段进人 , 不能为修改留有余地。\r\n" + 
   					"八\r\n" + 
   					"、\r\n" + 
   					"结束语\r\n" + 
   					"提高软件可修改性的方法还有很多 , 比如采用结构化程序设计方法 、 尽可能用高级语言编 程、 模块的作用域是控制域的子集 一 , 等等 。";
        System.out.println(100*levenshtein(str1,str2));  
    }  
  
    /** 
     * ����DNA���� ����ƴ�ּ�� ����������ʶ ������Ϯ��� 
     */  
    public static float levenshtein(String str1,String str2) {  
        //���������ַ����ĳ��ȡ�  
        int len1 = str1.length();  
        int len2 = str2.length();  
        //��������˵�����飬���ַ����ȴ�һ���ռ�  
        int[][] dif = new int[len1 + 1][len2 + 1];  
        //����ֵ������B��  
        for (int a = 0; a <= len1; a++) {  
            dif[a][0] = a;  
        }  
        for (int a = 0; a <= len2; a++) {  
            dif[0][a] = a;  
        }  
        //���������ַ��Ƿ�һ�����������ϵ�ֵ  
        int temp;  
        String a ="";
        String b ="";
        for (int i = 1; i <= len1; i++) {  
            for (int j = 1; j <= len2; j++) {  
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    temp = 0;  
                } else {  
                    temp = 1;  
                }  
                //ȡ����ֵ����С��  
                dif[i][j] = min(dif[i - 1][j - 1] + temp, dif[i][j - 1] + 1,  
                        dif[i - 1][j] + 1);  
            }  
        }  
//        System.out.println("1."+str1+"\n2."+str2);  

        float similarity =1 - (float) dif[len1][len2] / Math.max(str1.length(), str2.length());  
        System.out.println("相似度"+similarity*100);  
        return similarity;
    }  
  
    //�õ���Сֵ  
    private static int min(int... is) {  
        int min = Integer.MAX_VALUE;  
        for (int i : is) {  
            if (min > i) {  
                min = i;  
            }  
        }  
        return min;  
    }  
  
}